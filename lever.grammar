# This file describes & implements the syntax for the lever language.

file =>
    empty_list:
    statements

block => pass(statements): indent statements dedent

statements =>
    first:           block_statement
    append(lhs rhs): lhs=statements newline rhs=block_statement

block_statement =>
    pass: statement
    return(statement):
        kw_return:"return" statement
    if(statement block otherwise):
        kw_if:"if" statement block otherwise
    while(statement block):
        kw_while:"while" statement block
    local_assign(symbol block_statement):
        symbol assign_op:"=" block_statement
    upvalue_assign(symbol block_statement):
        symbol upvalue_assign_op:":=" block_statement
    op_assign(slot op block_statement):
        slot op assign_op:"=" block_statement
    setitem(expr idx block_statement):
        expr lb:"[" idx=expr rb:"]" assign_op:"=" block_statement
    setattr(expr symbol block_statement):
        expr dot:"." symbol assign_op:"=" block_statement
    for(symbol statement block):
        kw_for:"for" symbol kw_in:"in" statement block
    import(symbols_list):
        kw_import:"import" symbols_list

slot =>
    upvalue_slot: symbol
    attr_slot(expr symbol): expr dot:"." symbol
    item_slot(expr idx):    expr lb:"[" idx=expr rb:"]" 

otherwise =>
    done:
    elif(statement block otherwise):
        newline kw_elif:"elif" statement block otherwise
    else(block):
        newline kw_else:"else" block

statement =>
    pass: expr

expr =>
    expr3
    or(expr3 expr): expr3 kw_or:"or" expr

expr3 =>
    expr5
    and(expr5 expr3): expr5 kw_and:"and" expr3

expr5 =>
    expr8
    not(expr8): kw_not:"not" expr8

expr8 =>
    expr10
    in(l r): l=expr10 kw_in:"in" r=expr10
    not_in(l r): l=expr10 kw_not:"not" kw_in:"in" r=expr10
    binary: expr10 lt:"<" expr10
    binary: expr10 gt:">" expr10
    binary: expr10 eq:"==" expr10
    binary: expr10 ne:"!=" expr10
    binary: expr10 le:"<=" expr10
    binary: expr10 ge:">=" expr10

expr10 =>
    expr20
    binary: expr10 bitwise_or:"|" expr20

expr20 =>
    expr30
    binary: expr20 bitwise_xor:"^" expr30

expr30 =>
    expr50
    binary: expr30 bitwise_and:"&" expr50

expr50 =>
    expr100
    binary: expr50 bitwise_shl:"<<" expr100
    binary: expr50 bitwise_shr:">>" expr100

expr100 =>
    expr200
    binary: expr100 concat:"++" expr200
    binary: expr100 plus:"+" expr200
    binary: expr100 minus:"-" expr200

expr200 =>
    prefix
    binary: expr200 star:"*" prefix
    binary: expr200 slash:"/" prefix
    binary: expr200 percent:"%" prefix

prefix =>
    postfix
    prefix: plus:"+" postfix
    prefix: minus:"-" postfix

op =>
    bitwise_or:"|"
    bitwise_xor:"^"
    bitwise_and:"&"
    bitwise_shl:"<<"
    bitwise_shr:">>"
    concat:"++"
    plus:"+"
    minus:"-"
    percent:"%"
    slash:"/"
    star:"*"

# here we should still have bitwise not

postfix =>
    term
    call(postfix arguments):
        postfix lp:"(" arguments rp:")"
    getitem(postfix expr):
        postfix lb:"[" expr rb:"]"
    getattr(postfix symbol):
        postfix dot:"." symbol

arguments =>
    empty_list:
    arguments1
    pass(arguments1): arguments1 comma:","

arguments1 =>
    first: expr
    append(lst expr): lst=arguments1 comma:"," expr

term =>
    lookup:          symbol
    int:             int
    hex:             hex
    float:           float
    string:          string
    pass(expr):      lp:"(" expr rp:")"
    list(arguments): lb:"[" arguments rb:"]"
    function(bindings block):
        lp:"(" bindings rp:")" colon:":" block
    dict(pairs): lc:"{" pairs rc:"}"
    lookup(escaped_keyword): lc:"{" escaped_keyword rc:"}"
    lookup(string): percent:"%" string

bindings =>
    empty_list:
    bindings1
    pass(bindings1): bindings1 comma:","

bindings1 =>
    first: symbol
    append(lst symbol): lst=bindings1 comma:"," symbol

pairs =>
    empty_list:
    pairs1
    pass(pairs1): pairs1 comma:","

pairs1 =>
    first: pair
    append(lst pair): lst=pairs1 comma:"," pair

pair => tuple(k v): k=expr colon:":" v=expr

escaped_keyword =>
    pass: kw_import:"import"
    pass: kw_and:"and"
    pass: kw_or:"or"
    pass: kw_not:"not"

symbols_list =>
    first: symbol
    append(lst symbol): lst=symbols_list comma:"," symbol
